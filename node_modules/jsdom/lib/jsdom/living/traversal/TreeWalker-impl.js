"use strict";

<<<<<<< HEAD
const DOMException = require("domexception");
const { filter, FILTER_ACCEPT, FILTER_REJECT, FILTER_SKIP } = require("./helpers");

=======
const DOMException = require("../../web-idl/DOMException");
const idlUtils = require("../generated/utils");
const conversions = require("webidl-conversions");

// FIXME: Once NodeFilter is ported to IDL method, uncomment these.
const FILTER_ACCEPT = 1; // NodeFilter.FILTER_ACCEPT;
const FILTER_REJECT = 2; // NodeFilter.FILTER_REJECT;
const FILTER_SKIP = 3; // NodeFilter.FILTER_SKIP;
>>>>>>> master
const FIRST = false;
const LAST = true;
const NEXT = false;
const PREVIOUS = true;

<<<<<<< HEAD
exports.implementation = class TreeWalkerImpl {
  constructor(args, privateData) {
    this._active = false;
    this.root = privateData.root;
    this.whatToShow = privateData.whatToShow;
    this.filter = privateData.filter;

=======
function isNull(o) {
  return o === null || typeof o === "undefined";
}

class TreeWalkerImpl {
  constructor(args, privateData) {
    this.root = privateData.root;
    this.whatToShow = privateData.whatToShow;
    this.filter = privateData.filter;
>>>>>>> master
    this.currentNode = this.root;
  }

  get currentNode() {
    return this._currentNode;
  }

  set currentNode(node) {
<<<<<<< HEAD
    if (node === null) {
      throw new DOMException("Cannot set currentNode to null", "NotSupportedError");
=======
    if (isNull(node)) {
      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, "Cannot set currentNode to null");
>>>>>>> master
    }

    this._currentNode = node;
  }

  parentNode() {
    let node = this._currentNode;
<<<<<<< HEAD
    while (node !== null && node !== this.root) {
      node = node.parentNode;

      if (node !== null && filter(this, node) === FILTER_ACCEPT) {
=======
    while (!isNull(node) && node !== this.root) {
      node = node.parentNode;

      if (!isNull(node) && this._filterNode(node) === FILTER_ACCEPT) {
>>>>>>> master
        return (this._currentNode = node);
      }
    }
    return null;
  }

  firstChild() {
    return this._traverseChildren(FIRST);
  }

  lastChild() {
    return this._traverseChildren(LAST);
  }

  previousSibling() {
    return this._traverseSiblings(PREVIOUS);
  }

  nextSibling() {
    return this._traverseSiblings(NEXT);
  }

  previousNode() {
    let node = this._currentNode;

    while (node !== this.root) {
      let sibling = node.previousSibling;

<<<<<<< HEAD
      while (sibling !== null) {
        node = sibling;
        let result = filter(this, node);

        while (result !== FILTER_REJECT && node.hasChildNodes()) {
          node = node.lastChild;
          result = filter(this, node);
=======
      while (!isNull(sibling)) {
        node = sibling;
        let result = this._filterNode(node);

        while (result !== FILTER_REJECT && node.hasChildNodes()) {
          node = node.lastChild;
          result = this._filterNode(node);
>>>>>>> master
        }

        if (result === FILTER_ACCEPT) {
          return (this._currentNode = node);
        }

        sibling = node.previousSibling;
      }

<<<<<<< HEAD
      if (node === this.root || node.parentNode === null) {
=======
      if (node === this.root || isNull(node.parentNode)) {
>>>>>>> master
        return null;
      }

      node = node.parentNode;

<<<<<<< HEAD
      if (filter(this, node) === FILTER_ACCEPT) {
=======
      if (this._filterNode(node) === FILTER_ACCEPT) {
>>>>>>> master
        return (this._currentNode = node);
      }
    }

    return null;
  }

  nextNode() {
    let node = this._currentNode;
    let result = FILTER_ACCEPT;

    for (;;) {
      while (result !== FILTER_REJECT && node.hasChildNodes()) {
        node = node.firstChild;
<<<<<<< HEAD
        result = filter(this, node);
=======
        result = this._filterNode(node);
>>>>>>> master
        if (result === FILTER_ACCEPT) {
          return (this._currentNode = node);
        }
      }

      do {
        if (node === this.root) {
          return null;
        }

        const sibling = node.nextSibling;

<<<<<<< HEAD
        if (sibling !== null) {
=======
        if (!isNull(sibling)) {
>>>>>>> master
          node = sibling;
          break;
        }

        node = node.parentNode;
<<<<<<< HEAD
      } while (node !== null);

      if (node === null) {
        return null;
      }

      result = filter(this, node);
=======
      } while (!isNull(node));

      if (isNull(node)) {
        return null;
      }

      result = this._filterNode(node);
>>>>>>> master

      if (result === FILTER_ACCEPT) {
        return (this._currentNode = node);
      }
    }
  }

<<<<<<< HEAD
=======
  toString() {
    return "[object TreeWalker]";
  }

  _filterNode(node) {
    const n = node.nodeType - 1;

    if (!((1 << n) & this.whatToShow)) {
      return FILTER_SKIP;
    }

    const filter = this.filter;

    if (isNull(filter)) {
      return FILTER_ACCEPT;
    }

    let result;

    if (typeof filter === "function") {
      result = filter(idlUtils.wrapperForImpl(node));
    } else {
      result = filter.acceptNode(idlUtils.wrapperForImpl(node));
    }

    result = conversions["unsigned short"](result);

    return result;
  }

>>>>>>> master
  _traverseChildren(type) {
    let node = this._currentNode;
    node = type === FIRST ? node.firstChild : node.lastChild;

<<<<<<< HEAD
    if (node === null) {
=======
    if (isNull(node)) {
>>>>>>> master
      return null;
    }

    main: for (;;) {
<<<<<<< HEAD
      const result = filter(this, node);
=======
      const result = this._filterNode(node);
>>>>>>> master

      if (result === FILTER_ACCEPT) {
        return (this._currentNode = node);
      }

      if (result === FILTER_SKIP) {
        const child = type === FIRST ? node.firstChild : node.lastChild;

<<<<<<< HEAD
        if (child !== null) {
=======
        if (!isNull(child)) {
>>>>>>> master
          node = child;
          continue;
        }
      }

      for (;;) {
        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;

<<<<<<< HEAD
        if (sibling !== null) {
=======
        if (!isNull(sibling)) {
>>>>>>> master
          node = sibling;
          continue main;
        }

        const parent = node.parentNode;

<<<<<<< HEAD
        if (parent === null || parent === this.root || parent === this._currentNode) {
=======
        if (isNull(parent) || parent === this.root || parent === this._currentNode) {
>>>>>>> master
          return null;
        }

        node = parent;
      }
    }
  }

  _traverseSiblings(type) {
    let node = this._currentNode;

    if (node === this.root) {
      return null;
    }

    for (;;) {
      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;

<<<<<<< HEAD
      while (sibling !== null) {
        node = sibling;
        const result = filter(this, node);
=======
      while (!isNull(sibling)) {
        node = sibling;
        const result = this._filterNode(node);
>>>>>>> master

        if (result === FILTER_ACCEPT) {
          return (this._currentNode = node);
        }

        sibling = type === NEXT ? node.firstChild : node.lastChild;

<<<<<<< HEAD
        if (result === FILTER_REJECT || sibling === null) {
=======
        if (result === FILTER_REJECT || isNull(sibling)) {
>>>>>>> master
          sibling = type === NEXT ? node.nextSibling : node.previousSibling;
        }
      }

      node = node.parentNode;

<<<<<<< HEAD
      if (node === null || node === this.root) {
        return null;
      }

      if (filter(this, node) === FILTER_ACCEPT) {
=======
      if (isNull(node) || node === this.root) {
        return null;
      }

      if (this._filterNode(node) === FILTER_ACCEPT) {
>>>>>>> master
        return null;
      }
    }
  }
<<<<<<< HEAD
=======
}

module.exports = {
  implementation: TreeWalkerImpl
>>>>>>> master
};
