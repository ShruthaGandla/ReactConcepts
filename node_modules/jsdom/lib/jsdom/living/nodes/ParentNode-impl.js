"use strict";

<<<<<<< HEAD
const DOMException = require("domexception");
const idlUtils = require("../generated/utils");
const NodeList = require("../generated/NodeList");
const HTMLCollection = require("../generated/HTMLCollection");
const { addNwmatcher } = require("../helpers/selectors");
const { domSymbolTree } = require("../helpers/internal-constants");
const NODE_TYPE = require("../node-type");
const { memoizeQuery } = require("../../utils");
const { convertNodesIntoNode } = require("../node");
=======
const idlUtils = require("../generated/utils");

const nwmatcher = require("nwmatcher/src/nwmatcher-noqsa");
const DOMException = require("../../web-idl/DOMException");
const domSymbolTree = require("../helpers/internal-constants").domSymbolTree;
const NODE_TYPE = require("../node-type");
const createHTMLCollection = require("../html-collection").create;
const updateHTMLCollection = require("../html-collection").update;
const memoizeQuery = require("../../utils").memoizeQuery;
const createStaticNodeList = require("../node-list").createStatic;

// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial
// stages of Document initialization, there is no documentElement present yet.
function addNwmatcher(parentNode) {
  const document = parentNode._ownerDocument;

  if (!document._nwmatcher) {
    document._nwmatcher = nwmatcher({ document });
    document._nwmatcher.configure({ UNIQUE_ID: false });
  }

  return document._nwmatcher;
}
>>>>>>> master

class ParentNodeImpl {
  get children() {
    if (!this._childrenList) {
<<<<<<< HEAD
      this._childrenList = HTMLCollection.createImpl([], {
        element: this,
        query: () => domSymbolTree.childrenToArray(this, {
          filter: node => node.nodeType === NODE_TYPE.ELEMENT_NODE
        })
      });
    } else {
      this._childrenList._update();
=======
      this._childrenList = createHTMLCollection(this, () => {
        return domSymbolTree.childrenToArray(this, { filter(node) {
          return node.nodeType === NODE_TYPE.ELEMENT_NODE;
        } });
      });
    } else {
      updateHTMLCollection(this._childrenList);
>>>>>>> master
    }
    return this._childrenList;
  }

  get firstElementChild() {
    for (const child of domSymbolTree.childrenIterator(this)) {
      if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {
        return child;
      }
    }

    return null;
  }

  get lastElementChild() {
    for (const child of domSymbolTree.childrenIterator(this, { reverse: true })) {
      if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {
        return child;
      }
    }

    return null;
  }

  get childElementCount() {
    return this.children.length;
  }
<<<<<<< HEAD

  append(...nodes) {
    this.appendChild(convertNodesIntoNode(this._ownerDocument, nodes));
  }

  prepend(...nodes) {
    this.insertBefore(convertNodesIntoNode(this._ownerDocument, nodes), this.firstChild);
  }
}

ParentNodeImpl.prototype.querySelector = memoizeQuery(function (selectors) {
  if (shouldAlwaysSelectNothing(this)) {
    return null;
  }
  const matcher = addNwmatcher(this);

  try {
    return idlUtils.implForWrapper(matcher.first(selectors, idlUtils.wrapperForImpl(this)));
  } catch (e) {
    throw new DOMException(e.message, "SyntaxError");
  }
});

// WARNING: this returns a NodeList containing IDL wrappers instead of impls
ParentNodeImpl.prototype.querySelectorAll = memoizeQuery(function (selectors) {
  if (shouldAlwaysSelectNothing(this)) {
    return NodeList.create([], { nodes: [] });
  }
=======
}

ParentNodeImpl.prototype.querySelector = memoizeQuery(function (selectors) {
  const matcher = addNwmatcher(this);

  try {
    return matcher.first(selectors, idlUtils.wrapperForImpl(this));
  } catch (e) {
    throw new DOMException(DOMException.SYNTAX_ERR, e.message);
  }
});

ParentNodeImpl.prototype.querySelectorAll = memoizeQuery(function (selectors) {
>>>>>>> master
  const matcher = addNwmatcher(this);

  let list;
  try {
    list = matcher.select(selectors, idlUtils.wrapperForImpl(this));
  } catch (e) {
<<<<<<< HEAD
    throw new DOMException(e.message, "SyntaxError");
  }

  return NodeList.create([], { nodes: list.map(n => idlUtils.tryImplForWrapper(n)) });
});

function shouldAlwaysSelectNothing(elImpl) {
  // The latter clause is true during initialization.
  return !domSymbolTree.hasChildren(elImpl) || (elImpl === elImpl._ownerDocument && !elImpl.documentElement);
}

=======
    throw new DOMException(DOMException.SYNTAX_ERR, e.message);
  }

  return createStaticNodeList(list);
});

>>>>>>> master
module.exports = {
  implementation: ParentNodeImpl
};
