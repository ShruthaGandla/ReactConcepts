<<<<<<< HEAD
'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.matcherHint = exports.pluralize = exports.ensureNumbers = exports.ensureExpectedIsNumber = exports.ensureActualIsNumber = exports.ensureNoExpected = exports.printWithType = exports.printExpected = exports.printReceived = exports.highlightTrailingWhitespace = exports.stringify = exports.SUGGEST_TO_EQUAL = exports.RECEIVED_COLOR = exports.EXPECTED_COLOR = undefined;



=======
/**
 * Copyright (c) 2014, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

const chalk = require('chalk');
const prettyFormat = require('pretty-format');
const AsymmetricMatcherPlugin = require('pretty-format/build/plugins/AsymmetricMatcher');

const PLUGINS = [AsymmetricMatcherPlugin];
>>>>>>> master





<<<<<<< HEAD
var _chalk = require('chalk');var _chalk2 = _interopRequireDefault(_chalk);
var _jestGetType = require('jest-get-type');var _jestGetType2 = _interopRequireDefault(_jestGetType);
var _prettyFormat = require('pretty-format');var _prettyFormat2 = _interopRequireDefault(_prettyFormat);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var _prettyFormat$plugins =
=======
>>>>>>> master







<<<<<<< HEAD
_prettyFormat2.default.plugins; /**
                                 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                                 *
                                 * This source code is licensed under the MIT license found in the
                                 * LICENSE file in the root directory of this source tree.
                                 *
                                 * 
                                 */const AsymmetricMatcher = _prettyFormat$plugins.AsymmetricMatcher,DOMCollection = _prettyFormat$plugins.DOMCollection,DOMElement = _prettyFormat$plugins.DOMElement,Immutable = _prettyFormat$plugins.Immutable,ReactElement = _prettyFormat$plugins.ReactElement,ReactTestComponent = _prettyFormat$plugins.ReactTestComponent;const PLUGINS = [ReactTestComponent, ReactElement, DOMElement, DOMCollection, Immutable,
AsymmetricMatcher];


const EXPECTED_COLOR = exports.EXPECTED_COLOR = _chalk2.default.green;
const RECEIVED_COLOR = exports.RECEIVED_COLOR = _chalk2.default.red;
=======



const EXPECTED_COLOR = chalk.green;
const EXPECTED_BG = chalk.bgGreen;
const RECEIVED_COLOR = chalk.red;
const RECEIVED_BG = chalk.bgRed;
>>>>>>> master

const NUMBERS = [
'zero',
'one',
'two',
'three',
'four',
'five',
'six',
'seven',
'eight',
'nine',
'ten',
'eleven',
'twelve',
'thirteen'];


<<<<<<< HEAD
const SUGGEST_TO_EQUAL = exports.SUGGEST_TO_EQUAL = _chalk2.default.dim(
'Looks like you wanted to test for object/array equality with strict `toBe` matcher. You probably need to use `toEqual` instead.');


const stringify = exports.stringify = function (object) {let maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
=======
// get the type of a value with handling the edge cases like `typeof []`
// and `typeof null`
const getType = value => {
  if (typeof value === 'undefined') {
    return 'undefined';
  } else if (value === null) {
    return 'null';
  } else if (Array.isArray(value)) {
    return 'array';
  } else if (typeof value === 'boolean') {
    return 'boolean';
  } else if (typeof value === 'function') {
    return 'function';
  } else if (typeof value === 'number') {
    return 'number';
  } else if (typeof value === 'string') {
    return 'string';
  } else if (typeof value === 'object') {
    if (value.constructor === RegExp) {
      return 'regexp';
    } else if (value.constructor === Map) {
      return 'map';
    } else if (value.constructor === Set) {
      return 'set';
    }
    return 'object';
    // $FlowFixMe https://github.com/facebook/flow/issues/1015
  } else if (typeof value === 'symbol') {
    return 'symbol';
  }

  throw new Error(`value of unknown type: ${value}`);
};

const stringify = function (object) {let maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
>>>>>>> master
  const MAX_LENGTH = 10000;
  let result;

  try {
<<<<<<< HEAD
    result = (0, _prettyFormat2.default)(object, {
=======
    result = prettyFormat(object, {
>>>>>>> master
      maxDepth,
      min: true,
      plugins: PLUGINS });

  } catch (e) {
<<<<<<< HEAD
    result = (0, _prettyFormat2.default)(object, {
=======
    result = prettyFormat(object, {
>>>>>>> master
      callToJSON: false,
      maxDepth,
      min: true,
      plugins: PLUGINS });

  }

  return result.length >= MAX_LENGTH && maxDepth > 1 ?
  stringify(object, Math.floor(maxDepth / 2)) :
  result;
};

<<<<<<< HEAD
const highlightTrailingWhitespace = exports.highlightTrailingWhitespace = text =>
text.replace(/\s+$/gm, _chalk2.default.inverse('$&'));

const printReceived = exports.printReceived = object =>
RECEIVED_COLOR(highlightTrailingWhitespace(stringify(object)));
const printExpected = exports.printExpected = value =>
EXPECTED_COLOR(highlightTrailingWhitespace(stringify(value)));

const printWithType = exports.printWithType = (
=======
const highlightTrailingWhitespace = (text, bgColor) =>
text.replace(/\s+$/gm, bgColor('$&'));

const printReceived = object => highlightTrailingWhitespace(
RECEIVED_COLOR(stringify(object)),
RECEIVED_BG);

const printExpected = value => highlightTrailingWhitespace(
EXPECTED_COLOR(stringify(value)),
EXPECTED_BG);


const printWithType = (
>>>>>>> master
name,
received,
print) =>
{
<<<<<<< HEAD
  const type = (0, _jestGetType2.default)(received);
  return (
    name +
    ':' + (
    type !== 'null' && type !== 'undefined' ? '\n  ' + type + ': ' : ' ') +
=======
  const type = getType(received);
  return (
    name + ':' + (
    type !== 'null' && type !== 'undefined' ?
    '\n  ' + type + ': ' :
    ' ') +
>>>>>>> master
    print(received));

};

<<<<<<< HEAD
const ensureNoExpected = exports.ensureNoExpected = (expected, matcherName) => {
  matcherName || (matcherName = 'This');
  if (typeof expected !== 'undefined') {
    throw new Error(
    matcherHint('[.not]' + matcherName, undefined, '') +
    '\n\n' +
=======
const ensureNoExpected = (expected, matcherName) => {
  matcherName || (matcherName = 'This');
  if (typeof expected !== 'undefined') {
    throw new Error(
    matcherHint('[.not]' + matcherName, undefined, '') + '\n\n' +
>>>>>>> master
    'Matcher does not accept any arguments.\n' +
    printWithType('Got', expected, printExpected));

  }
};

<<<<<<< HEAD
const ensureActualIsNumber = exports.ensureActualIsNumber = (actual, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof actual !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) +
    '\n\n' +
    `Received value must be a number.\n` +
=======
const ensureActualIsNumber = (actual, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof actual !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
    `Actual value must be a number.\n` +
>>>>>>> master
    printWithType('Received', actual, printReceived));

  }
};

<<<<<<< HEAD
const ensureExpectedIsNumber = exports.ensureExpectedIsNumber = (expected, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof expected !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) +
    '\n\n' +
=======
const ensureExpectedIsNumber = (expected, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof expected !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
>>>>>>> master
    `Expected value must be a number.\n` +
    printWithType('Got', expected, printExpected));

  }
};

<<<<<<< HEAD
const ensureNumbers = exports.ensureNumbers = (
actual,
expected,
matcherName) =>
{
=======
const ensureNumbers = (actual, expected, matcherName) => {
>>>>>>> master
  ensureActualIsNumber(actual, matcherName);
  ensureExpectedIsNumber(expected, matcherName);
};

<<<<<<< HEAD
const pluralize = exports.pluralize = (word, count) =>
(NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');

const matcherHint = exports.matcherHint = function (
=======
const pluralize =
(word, count) =>
(NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');

const matcherHint = function (
>>>>>>> master
matcherName)






{let received = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'received';let expected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'expected';let options = arguments[3];
  const secondArgument = options && options.secondArgument;
  const isDirectExpectCall = options && options.isDirectExpectCall;
  return (
<<<<<<< HEAD
    _chalk2.default.dim('expect' + (isDirectExpectCall ? '' : '(')) +
    RECEIVED_COLOR(received) +
    _chalk2.default.dim((isDirectExpectCall ? '' : ')') + matcherName + '(') +
    EXPECTED_COLOR(expected) + (
    secondArgument ? `, ${EXPECTED_COLOR(secondArgument)}` : '') +
    _chalk2.default.dim(')'));

};
=======
    chalk.dim('expect' + (isDirectExpectCall ? '' : '(')) +
    RECEIVED_COLOR(received) +
    chalk.dim((isDirectExpectCall ? '' : ')') + matcherName + '(') +
    EXPECTED_COLOR(expected) + (
    secondArgument ? `, ${EXPECTED_COLOR(secondArgument)}` : '') +
    chalk.dim(')'));

};

module.exports = {
  EXPECTED_BG,
  EXPECTED_COLOR,
  RECEIVED_BG,
  RECEIVED_COLOR,
  ensureActualIsNumber,
  ensureExpectedIsNumber,
  ensureNoExpected,
  ensureNumbers,
  getType,
  highlightTrailingWhitespace,
  matcherHint,
  pluralize,
  printExpected,
  printReceived,
  printWithType,
  stringify };
>>>>>>> master
